<!DOCTYPE html>
<html lang="tr">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Hackpot Bahis</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/ethers/6.7.0/ethers.umd.min.js"></script>
    <link rel="stylesheet" href="global.css">
    <style>
        body {
            font-family: Arial, sans-serif;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            margin: 0;
            background-color: #f0f2f5;
        }

        .main-container {
            display: flex;
            gap: 20px;
        }

        .container {
            background-color: white;
            padding: 20px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0, 0, 0, 0.1);
        }

        .bets-container {
            min-width: 300px;
            max-height: 400px;
            overflow-y: auto;
        }

        .bet-item {
            padding: 10px;
            border-bottom: 1px solid #eee;
        }

        input {
            padding: 10px;
            margin-right: 10px;
            border: 1px solid #ddd;
            border-radius: 5px;
            width: 200px;
        }

        button {
            padding: 10px 20px;
            background-color: #4CAF50;
            color: white;
            border: none;
            border-radius: 5px;
            cursor: pointer;
        }

        button:hover {
            background-color: #45a049;
        }

        canvas {
            border-radius: 50%;
            background-color: #1a2634;
            box-shadow: 0 0 10px rgba(0, 0, 0, 0.5);
        }

        #totalBetsHeader {
            transition: background-color 0.5s ease;
        }
    </style>
</head>

<body>
    <div id="totalBetsHeader"
        style="position: fixed; top: 0; left: 0; right: 0; background-color: #4CAF50; color: white; padding: 10px; text-align: center; font-weight: bold;">
        TOTAL BETS: 0 TOKEN</div>

    <!-- Ã‡ark iÃ§in canvas ekleyelim -->
    <canvas id="wheelCanvas" width="300" height="300" style="margin: 20px auto; display: block;"></canvas>

    <!-- Kazanan adresi iÃ§in div'i gÃ¼ncelle -->
    <div id="winnerDisplay"
        style="text-align: center; margin: 10px auto; padding: 10px; font-weight: bold; color: #333; position: fixed; bottom: 0; left: 0; right: 0; background-color: white; box-shadow: 0 -2px 10px rgba(0,0,0,0.1);">
        KAZANAN ADRES: 0x0000000000000000000000000000000000000000
    </div>

    <!-- Timer div'ini kaldÄ±r ve yerine bahis durumu div'i ekle -->
    <div id="betStatusDisplay"
        style="position: fixed; top: 60px; right: 20px; font-size: 18px; font-weight: bold; padding: 15px; border-radius: 10px; box-shadow: 0 2px 10px rgba(0,0,0,0.1);">
        Bahis Durumu Kontrol Ediliyor...
    </div>

    <div class="main-container">
        <div class="container">
            <input type="number" id="betAmount" placeholder="Bahis miktarÄ±nÄ± girin">
            <button onclick="placeBet()">Bahis Yap</button>
        </div>
        <div class="container bets-container" id="betsList">
            <h3>Aktif Bahisler</h3>
            <div id="betsContent"></div>
        </div>
    </div>

    <script>
        const HACKPOT_ADDRESS = '0xFE3640B7096e62c5065F082BF22437D110342E17';
        const TOKEN_ADDRESS = '0x84C96D49efd12BD71789576ffcF5aA8A72B8A7eb';

        const hackpotABI = [
            "function betTokens(uint256 amount, uint256 deadline, uint8 v, bytes32 r, bytes32 s)",
            "function bets(address) view returns (uint256)",
            "function players(uint256) view returns (address)",
            "event betPlaced(address player, uint256 amount)",
            "event winnerSelected(address winner, uint256 totalBets)",
            "event executionTimeUpdated(uint256 lastExecutionTime)",
            "event betStarted(uint256 requestId)",
            "event totalBetsUpdated(uint256 totalBets)",
            "function winner() view returns (address)",
            "function lastExecutionTime() view returns (uint256)",
            "function isSelectingWinner() view returns (bool)"
        ];

        const tokenABI = [
            "function permit(address owner, address spender, uint256 value, uint256 deadline, uint8 v, bytes32 r, bytes32 s)",
            "function nonces(address) view returns (uint256)",
            "function name() view returns (string)"
        ];

        let provider;
        let hackpotContract;
        let totalBetsAmount = 0;

        // TÃ¼m bahisleri tutacak global sÃ¶zlÃ¼k
        let allBets = {};

        let currentRotation = 0;
        let isSpinning = false;
        let winnerAddress = null;
        let currentUserAddress = null;
        let lastWinnerAddress = '0x0000000000000000000000000000000000000000';

        // Renk dizisini global olarak tanÄ±mla
        const colors = ['#FF0000', '#0000FF', '#FFFF00', '#800080', '#FFA500', '#00FF00', '#FF1493', '#00FFFF'];

        function updateTotalDisplay() {
            let totalAmount = 0;
            // TÃ¼m bahisleri topla
            for (let address in allBets) {
                totalAmount += parseFloat(allBets[address]);
            }
            document.getElementById('totalBetsHeader').innerHTML = `TOTAL BETS: ${totalAmount.toFixed(2)} TOKEN`;
        }

        function updateBetsDisplay() {
            const betsContent = document.getElementById('betsContent');
            const oldScrollTop = betsContent.scrollTop;

            betsContent.innerHTML = '';

            // Bahisleri sÄ±rala
            const sortedBets = Object.entries(allBets).sort((a, b) => parseFloat(b[1]) - parseFloat(a[1]));

            sortedBets.forEach((bet, index) => {
                const [player, amount] = bet;
                const betElement = document.createElement('div');
                betElement.className = 'bet-item';
                betElement.style.display = 'flex';
                betElement.style.alignItems = 'center';
                betElement.style.gap = '10px';

                // Renk karesi
                const colorSquare = document.createElement('div');
                colorSquare.style.width = '20px';
                colorSquare.style.height = '20px';
                colorSquare.style.backgroundColor = colors[index % colors.length];
                colorSquare.style.border = '1px solid #333';

                const betInfo = document.createElement('div');
                betInfo.innerHTML = `
                    <div>Adres: ${player}</div>
                    <div>Miktar: ${amount} TOKEN</div>
                `;

                betElement.appendChild(colorSquare);
                betElement.appendChild(betInfo);
                betsContent.appendChild(betElement);
            });

            betsContent.scrollTop = oldScrollTop;
            drawWheel();
        }

        async function loadExistingBets() {
            try {
                // Winner adresini kontrol et
                try {
                    const currentWinner = await hackpotContract.winner();
                    if (currentWinner && currentWinner !== '0x0000000000000000000000000000000000000000') {
                        if (currentWinner !== lastWinnerAddress && !isSpinning) {
                            lastWinnerAddress = currentWinner;
                            updateWinnerDisplay(currentWinner);
                            spinWheel(currentWinner);
                            return;
                        }
                    } else {
                        updateWinnerDisplay('0x0000000000000000000000000000000000000000');
                    }
                } catch (error) {
                    console.error("Winner kontrolÃ¼nde hata:", error);
                    updateWinnerDisplay('0x0000000000000000000000000000000000000000');
                }

                // EÄŸer Ã§ark dÃ¶nÃ¼yorsa bahisleri gÃ¼ncelleme
                if (isSpinning) return;

                let index = 0;
                let tempBets = {};

                // Mevcut bahisleri yÃ¼kle
                while (true) {
                    try {
                        const playerAddress = await hackpotContract.players(index);
                        const betAmount = await hackpotContract.bets(playerAddress);

                        if (betAmount > 0) {
                            const amountInEther = ethers.formatEther(betAmount);
                            tempBets[playerAddress] = amountInEther;
                        }

                        index++;
                    } catch (error) {
                        break;
                    }
                }

                // Global sÃ¶zlÃ¼ÄŸÃ¼ gÃ¼ncelle
                allBets = tempBets;

                // UI'Ä± gÃ¼ncelle
                updateBetsDisplay();
                updateTotalDisplay();
                drawWheel();

            } catch (error) {
                console.error("Mevcut bahisler yÃ¼klenirken hata:", error);
            }
        }

        async function initializeContracts() {
            try {
                provider = new ethers.BrowserProvider(window.ethereum);
                hackpotContract = new ethers.Contract(HACKPOT_ADDRESS, hackpotABI, provider);

                // KullanÄ±cÄ± adresini al
                const accounts = await provider.send("eth_requestAccounts", []);
                currentUserAddress = accounts[0];

                // Event dinleyicileri
                hackpotContract.on("winnerSelected", (winner, totalBets) => {
                    const totalBetsInEther = ethers.formatEther(totalBets);
                    lastWinnerAddress = winner;
                    spinWheel(winner);
                });

                hackpotContract.on("betPlaced", (player, amount) => {
                    const amountInEther = ethers.formatEther(amount);
                    if (allBets[player]) {
                        allBets[player] = (parseFloat(allBets[player]) + parseFloat(amountInEther)).toString();
                    } else {
                        allBets[player] = amountInEther;
                    }
                    updateBetsDisplay();
                    updateTotalDisplay();
                });

                hackpotContract.on("executionTimeUpdated", () => {
                    allBets = {};
                    document.getElementById('betsContent').innerHTML = '<h4>Yeni Tur BaÅŸladÄ±!</h4>';
                    updateTotalDisplay();
                });

                // Ä°lk yÃ¼kleme
                await loadExistingBets();

                // Ä°lk bahis durumu kontrolÃ¼
                await updateBetStatus();
                // Her 2 saniyede bir bahis durumunu kontrol et
                setInterval(updateBetStatus, 2000);

            } catch (error) {
                console.error("Contract initialization error:", error);
                updateWinnerDisplay('0x0000000000000000000000000000000000000000');
            }
        }

        async function placeBet() {
            try {
                if (!window.ethereum) {
                    alert('MetaMask yÃ¼klÃ¼ deÄŸil!');
                    return;
                }

                await window.ethereum.request({ method: 'eth_requestAccounts' });
                const provider = new ethers.BrowserProvider(window.ethereum);
                const signer = await provider.getSigner();
                const userAddress = await signer.getAddress();

                const betAmount = document.getElementById('betAmount').value;
                const amount = ethers.parseEther(betAmount);
                const deadline = Math.floor(Date.now() / 1000) + 3600;

                const tokenContract = new ethers.Contract(TOKEN_ADDRESS, tokenABI, signer);
                const hackpotContract = new ethers.Contract(HACKPOT_ADDRESS, hackpotABI, signer);

                const domain = {
                    name: await tokenContract.name(),
                    version: "1",
                    chainId: (await provider.getNetwork()).chainId,
                    verifyingContract: TOKEN_ADDRESS
                };

                const types = {
                    Permit: [
                        { name: "owner", type: "address" },
                        { name: "spender", type: "address" },
                        { name: "value", type: "uint256" },
                        { name: "nonce", type: "uint256" },
                        { name: "deadline", type: "uint256" }
                    ]
                };

                const nonce = await tokenContract.nonces(userAddress);
                const value = {
                    owner: userAddress,
                    spender: HACKPOT_ADDRESS,
                    value: amount,
                    nonce: nonce,
                    deadline: deadline
                };

                const signature = await signer.signTypedData(domain, types, value);
                const sig = ethers.Signature.from(signature);

                const tx = await hackpotContract.betTokens(
                    amount,
                    deadline,
                    sig.v,
                    sig.r,
                    sig.s
                );

                await tx.wait();
                alert('Bahis baÅŸarÄ±yla yapÄ±ldÄ±!');

            } catch (error) {
                console.error('Hata:', error);
                alert('Bahis yapÄ±lÄ±rken bir hata oluÅŸtu: ' + error.message);
            }
        }

        // Ã‡arkÄ± dÃ¶ndÃ¼rme animasyonu
        function drawWheel() {
            const canvas = document.getElementById('wheelCanvas');
            const ctx = canvas.getContext('2d');
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = canvas.width / 2 - 20;

            ctx.clearRect(0, 0, canvas.width, canvas.height); // Canvas'Ä± temizle

            // Arka plan dairesini Ã§iz
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
            ctx.fillStyle = '#2c3e50';
            ctx.fill();
            ctx.strokeStyle = '#ff00ff';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Dilimleri Ã§iz
            let startAngle = 0;
            const totalBetAmount = Object.values(allBets).reduce((sum, bet) => sum + parseFloat(bet), 0);

            // Sadece Ã§arkÄ± dÃ¶ndÃ¼r
            ctx.save();
            ctx.translate(centerX, centerY);
            ctx.rotate(currentRotation * Math.PI / 180);
            ctx.translate(-centerX, -centerY);

            // Her bahisÃ§i iÃ§in dilim Ã§iz
            const sortedBets = Object.entries(allBets).sort((a, b) => parseFloat(b[1]) - parseFloat(a[1]));
            sortedBets.forEach((bet, index) => {
                const [player, betAmount] = bet;
                const sliceAngle = (parseFloat(betAmount) / totalBetAmount) * (2 * Math.PI);

                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.arc(centerX, centerY, radius - 2, startAngle, startAngle + sliceAngle);
                ctx.lineTo(centerX, centerY);
                ctx.fillStyle = colors[index % colors.length];
                ctx.fill();
                ctx.strokeStyle = '#333';
                ctx.stroke();

                startAngle += sliceAngle;
            });

            // Ä°Ã§ daireyi Ã§iz
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius - 60, 0, 2 * Math.PI);
            ctx.fillStyle = '#2c3e50';
            ctx.fill();
            ctx.strokeStyle = '#ff00ff';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Merkez noktayÄ± Ã§iz
            ctx.beginPath();
            ctx.arc(centerX, centerY, 5, 0, 2 * Math.PI);
            ctx.fillStyle = '#ff00ff';
            ctx.fill();

            ctx.restore();

            // Ok'u en son ve dÃ¶ndÃ¼rmeden Ã§iz
            ctx.beginPath();
            ctx.moveTo(centerX, centerY - radius + 10);
            ctx.lineTo(centerX - 15, centerY - radius - 10);
            ctx.lineTo(centerX + 15, centerY - radius - 10);
            ctx.closePath();
            ctx.fillStyle = '#333';
            ctx.fill();
            ctx.strokeStyle = '#ff00ff';
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        function spinWheel(winner) {
            if (isSpinning) return;
            isSpinning = true;

            // Mevcut bahisleri kopyala
            const currentBets = { ...allBets };

            let winnerAngle = 0;
            let currentAngle = 0;
            const totalBetAmount = Object.values(currentBets).reduce((sum, bet) => sum + parseFloat(bet), 0);

            const sortedBets = Object.entries(currentBets).sort((a, b) => parseFloat(b[1]) - parseFloat(a[1]));

            for (let [player, betAmount] of sortedBets) {
                const sliceAngle = (parseFloat(betAmount) / totalBetAmount) * (2 * Math.PI);
                if (player.toLowerCase() === winner.toLowerCase()) {
                    winnerAngle = currentAngle + (sliceAngle / 2);
                    break;
                }
                currentAngle += sliceAngle;
            }

            let targetRotation = (winnerAngle * 180 / Math.PI) + 1080;
            let startTime = null;
            const duration = 5000;

            function animate(currentTime) {
                if (!startTime) startTime = currentTime;
                const elapsed = currentTime - startTime;
                const progress = Math.min(elapsed / duration, 1);

                const easeOut = 1 - Math.pow(1 - progress, 3);
                currentRotation = easeOut * targetRotation;

                // Ã‡ark Ã§iziminde kopyalanmÄ±ÅŸ bahisleri kullan
                drawWheelWithBets(currentBets);

                if (progress < 1) {
                    requestAnimationFrame(animate);
                } else {
                    isSpinning = false;
                    updateWinnerDisplay(winner);
                    showWinnerMessage(winner);
                }
            }

            requestAnimationFrame(animate);
        }

        // Yeni fonksiyon: Belirli bahislerle Ã§ark Ã§izimi
        function drawWheelWithBets(bets) {
            const canvas = document.getElementById('wheelCanvas');
            const ctx = canvas.getContext('2d');
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;
            const radius = canvas.width / 2 - 20;

            ctx.clearRect(0, 0, canvas.width, canvas.height); // Canvas'Ä± temizle

            // Arka plan dairesini Ã§iz
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius, 0, 2 * Math.PI);
            ctx.fillStyle = '#2c3e50';
            ctx.fill();
            ctx.strokeStyle = '#ff00ff';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Dilimleri Ã§iz
            let startAngle = 0;
            const totalBetAmount = Object.values(bets).reduce((sum, bet) => sum + parseFloat(bet), 0);

            // Sadece Ã§arkÄ± dÃ¶ndÃ¼r
            ctx.save();
            ctx.translate(centerX, centerY);
            ctx.rotate(currentRotation * Math.PI / 180);
            ctx.translate(-centerX, -centerY);

            // Her bahisÃ§i iÃ§in dilim Ã§iz
            const sortedBets = Object.entries(bets).sort((a, b) => parseFloat(b[1]) - parseFloat(a[1]));
            sortedBets.forEach((bet, index) => {
                const [player, betAmount] = bet;
                const sliceAngle = (parseFloat(betAmount) / totalBetAmount) * (2 * Math.PI);

                ctx.beginPath();
                ctx.moveTo(centerX, centerY);
                ctx.arc(centerX, centerY, radius - 2, startAngle, startAngle + sliceAngle);
                ctx.lineTo(centerX, centerY);
                ctx.fillStyle = colors[index % colors.length];
                ctx.fill();
                ctx.strokeStyle = '#333';
                ctx.stroke();

                startAngle += sliceAngle;
            });

            // Ä°Ã§ daireyi Ã§iz
            ctx.beginPath();
            ctx.arc(centerX, centerY, radius - 60, 0, 2 * Math.PI);
            ctx.fillStyle = '#2c3e50';
            ctx.fill();
            ctx.strokeStyle = '#ff00ff';
            ctx.lineWidth = 2;
            ctx.stroke();

            // Merkez noktayÄ± Ã§iz
            ctx.beginPath();
            ctx.arc(centerX, centerY, 5, 0, 2 * Math.PI);
            ctx.fillStyle = '#ff00ff';
            ctx.fill();

            ctx.restore();

            // Ok'u en son ve dÃ¶ndÃ¼rmeden Ã§iz
            ctx.beginPath();
            ctx.moveTo(centerX, centerY - radius + 10);
            ctx.lineTo(centerX - 15, centerY - radius - 10);
            ctx.lineTo(centerX + 15, centerY - radius - 10);
            ctx.closePath();
            ctx.fillStyle = '#333';
            ctx.fill();
            ctx.strokeStyle = '#ff00ff';
            ctx.lineWidth = 2;
            ctx.stroke();
        }

        function updateWinnerDisplay(winner) {
            const winnerDisplay = document.getElementById('winnerDisplay');
            winnerDisplay.innerHTML = `KAZANAN ADRES: ${winner}`;
            if (winner.toLowerCase() === currentUserAddress?.toLowerCase()) {
                winnerDisplay.style.color = '#FFD700';
            } else {
                winnerDisplay.style.color = '#4CAF50';
            }
        }

        function showWinnerMessage(winner) {
            const header = document.getElementById('totalBetsHeader');
            lastWinnerAddress = winner;
            updateWinnerDisplay(winner);

            if (winner.toLowerCase() === currentUserAddress?.toLowerCase()) {
                header.innerHTML = 'TEBRÄ°KLER KAZANDINIZ! ðŸŽ‰';
                header.style.backgroundColor = '#FFD700';
            } else {
                header.innerHTML = 'TOTAL BETS: 0 TOKEN';
                header.style.backgroundColor = '#4CAF50';
            }

            // 5 saniye sonra sÄ±fÄ±rlama iÅŸlemlerini yap
            setTimeout(() => {
                // Ã–nce bahisleri sÄ±fÄ±rla
                allBets = {};
                // Sonra UI'Ä± gÃ¼ncelle
                document.getElementById('betsContent').innerHTML = '';
                header.innerHTML = 'TOTAL BETS: 0 TOKEN';
                header.style.backgroundColor = '#4CAF50';
                updateTotalDisplay();
                drawWheel();
            }, 5000); // 5 saniye bekle
        }

        // Timer ile ilgili tÃ¼m kodlarÄ± kaldÄ±r ve yerine bahis durumu kontrolÃ¼ ekle
        async function updateBetStatus() {
            try {
                const isSelectingWinner = await hackpotContract.isSelectingWinner();
                const statusDisplay = document.getElementById('betStatusDisplay');

                if (isSelectingWinner) {
                    statusDisplay.innerHTML = 'Bahisler KapalÄ±';
                    statusDisplay.style.backgroundColor = '#FF6B6B'; // KÄ±rmÄ±zÄ±
                    statusDisplay.style.color = 'white';
                } else {
                    statusDisplay.innerHTML = 'Bahisler AÃ§Ä±k';
                    statusDisplay.style.backgroundColor = '#4CAF50'; // YeÅŸil
                    statusDisplay.style.color = 'white';
                }
            } catch (error) {
                console.error("Bahis durumu kontrolÃ¼nde hata:", error);
            }
        }

        // Sayfa yÃ¼klendiÄŸinde Ã§arkÄ± Ã§iz ve event dinleyicilerini ve mevcut bahisleri baÅŸlat
        window.addEventListener('load', () => {
            drawWheel();
            initializeContracts();
        });
    </script>
</body>

</html>